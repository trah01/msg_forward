# SMS Forwarder - ESPHome 配置
# 
# 使用 ESP32C3 + ML307R 4G 模块实现短信转发
# 硬件接线:
#   ESP32 GPIO3 (TXD) -> ML307 RX
#   ESP32 GPIO4 (RXD) -> ML307 TX
#   ESP32 GND -> ML307 GND
#   ESP32 5V -> ML307 VCC & EN

substitutions:
  device_name: "sms-forwarder"
  friendly_name: "短信转发器"
  # MQTT 设备 ID (会自动使用 MAC 地址后6位)
  mqtt_prefix: "sms"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "ESP32C3 + ML307R 短信转发器"
  project:
    name: "msg_forward.sms_forwarder"
    version: "1.0.0"
  on_boot:
    priority: -100
    then:
      - logger.log: "设备启动完成"
      - delay: 3s
      - script.execute: init_modem

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# 启用日志
logger:
  level: DEBUG
  baud_rate: 115200

# 启用 API (用于 Home Assistant 集成)
api:
  encryption:
    key: !secret api_encryption_key
  services:
    - service: send_sms
      variables:
        phone: string
        message: string
      then:
        - script.execute:
            id: send_sms_script
            phone_number: !lambda 'return phone;'
            sms_message: !lambda 'return message;'

# OTA 更新
ota:
  - platform: esphome
    password: !secret ota_password

# WiFi 配置
wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
    # 可以添加更多 WiFi 网络
    # - ssid: !secret wifi_ssid_2
    #   password: !secret wifi_password_2
  ap:
    ssid: "SMS-Forwarder-AP"
    password: !secret ap_password

captive_portal:

# Web 服务器
web_server:
  port: 80
  auth:
    username: !secret web_username
    password: !secret web_password

# mDNS
mdns:
  disabled: false

# MQTT 配置 (可选,用于消息推送)
mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_username
  password: !secret mqtt_password
  topic_prefix: ${mqtt_prefix}/${device_name}
  # 收到短信时发布的主题
  on_message:
    - topic: ${mqtt_prefix}/${device_name}/sms/send
      then:
        - lambda: |-
            // 解析 JSON {"phone":"xxx", "message":"xxx"}
            JsonDocument doc;
            deserializeJson(doc, x);
            std::string phone = doc["phone"].as<std::string>();
            std::string message = doc["message"].as<std::string>();
            if (!phone.empty() && !message.empty()) {
              id(send_sms_script).execute(phone, message);
            }

# UART 配置 (连接 ML307R 4G 模块)
uart:
  id: uart_modem
  tx_pin: GPIO3
  rx_pin: GPIO4
  baud_rate: 115200
  rx_buffer_size: 512

# 全局变量
globals:
  - id: modem_initialized
    type: bool
    initial_value: 'false'
  - id: sms_buffer
    type: std::string
    initial_value: '""'
  - id: waiting_for_pdu
    type: bool
    initial_value: 'false'
  - id: last_sender
    type: std::string
    initial_value: '""'
  - id: last_message
    type: std::string
    initial_value: '""'
  - id: last_timestamp
    type: std::string
    initial_value: '""'

# 文本传感器 (用于显示短信内容)
text_sensor:
  - platform: template
    name: "最新短信发送者"
    id: sms_sender
    icon: "mdi:account"
    
  - platform: template
    name: "最新短信内容"
    id: sms_content
    icon: "mdi:message-text"
    
  - platform: template
    name: "短信时间"
    id: sms_time
    icon: "mdi:clock"
    
  - platform: template
    name: "4G 状态"
    id: lte_status
    icon: "mdi:signal-4g"
    
  - platform: template
    name: "APN"
    id: apn_info
    icon: "mdi:access-point-network"
    
  - platform: wifi_info
    ip_address:
      name: "IP 地址"
    ssid:
      name: "WiFi SSID"

# 数值传感器
sensor:
  - platform: wifi_signal
    name: "WiFi 信号强度"
    update_interval: 60s
    
  - platform: template
    name: "4G 信号强度"
    id: lte_rsrp
    unit_of_measurement: "dBm"
    icon: "mdi:signal"
    accuracy_decimals: 0
    
  - platform: uptime
    name: "运行时间"
    
  - platform: template
    name: "收到短信数"
    id: sms_received_count
    icon: "mdi:email-receive"
    accuracy_decimals: 0
    
  - platform: template
    name: "发送短信数"
    id: sms_sent_count
    icon: "mdi:email-send"
    accuracy_decimals: 0

# 二进制传感器
binary_sensor:
  - platform: template
    name: "4G 模块在线"
    id: modem_online
    icon: "mdi:cellphone-link"
    
  - platform: template
    name: "网络附着"
    id: network_attached
    icon: "mdi:signal"

# 开关
switch:
  - platform: restart
    name: "重启设备"
    
  - platform: template
    name: "定时 Ping 保号"
    id: timer_ping_enabled
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

# 按钮
button:
  - platform: template
    name: "手动 Ping"
    icon: "mdi:access-point-network"
    on_press:
      - script.execute: do_ping
      
  - platform: template
    name: "刷新状态"
    icon: "mdi:refresh"
    on_press:
      - script.execute: query_status

# 脚本
script:
  # 初始化调制解调器
  - id: init_modem
    mode: single
    then:
      - logger.log: "初始化 ML307R 4G 模块..."
      # 发送 AT 命令检测模块
      - uart.write: 
          id: uart_modem
          data: "AT\r\n"
      - delay: 1s
      # 设置短信自动上报模式
      - uart.write: 
          id: uart_modem
          data: "AT+CNMI=2,2,0,0,0\r\n"
      - delay: 500ms
      # 设置 PDU 模式
      - uart.write: 
          id: uart_modem
          data: "AT+CMGF=0\r\n"
      - delay: 500ms
      # 查询网络附着状态
      - uart.write: 
          id: uart_modem
          data: "AT+CGATT?\r\n"
      - delay: 1s
      - lambda: |-
          id(modem_initialized) = true;
          ESP_LOGI("modem", "4G 模块初始化完成");

  # 发送短信
  - id: send_sms_script
    mode: queued
    parameters:
      phone_number: string
      sms_message: string
    then:
      - logger.log: 
          format: "准备发送短信到 %s"
          args: ['phone_number.c_str()']
      - lambda: |-
          // 注意: 完整的 PDU 编码需要更复杂的实现
          // 这里使用 Text 模式发送（需要先切换模式）
          id(uart_modem).write_str("AT+CMGF=1\r\n");
      - delay: 500ms
      - lambda: |-
          char cmd[128];
          snprintf(cmd, sizeof(cmd), "AT+CMGS=\"%s\"\r\n", phone_number.c_str());
          id(uart_modem).write_str(cmd);
      - delay: 500ms
      - lambda: |-
          id(uart_modem).write_str(sms_message.c_str());
          id(uart_modem).write_byte(0x1A);  // Ctrl+Z
      - delay: 5s
      # 切回 PDU 模式
      - uart.write: 
          id: uart_modem
          data: "AT+CMGF=0\r\n"
      - lambda: |-
          id(sms_sent_count).publish_state(id(sms_sent_count).state + 1);

  # 执行 Ping 测试
  - id: do_ping
    mode: single
    then:
      - logger.log: "执行 Ping 测试..."
      - uart.write: 
          id: uart_modem
          data: "AT+CGACT=1,1\r\n"
      - delay: 1s
      - uart.write: 
          id: uart_modem
          data: "AT+MPING=1,\"8.8.8.8\",4,32,255\r\n"
      - delay: 5s
      - uart.write: 
          id: uart_modem
          data: "AT+CGACT=0,1\r\n"

  # 查询状态
  - id: query_status
    mode: single
    then:
      - logger.log: "查询模块状态..."
      # 查询信号强度
      - uart.write: 
          id: uart_modem
          data: "AT+CSQ\r\n"
      - delay: 500ms
      # 查询网络附着
      - uart.write: 
          id: uart_modem
          data: "AT+CGATT?\r\n"
      - delay: 500ms
      # 查询 APN
      - uart.write: 
          id: uart_modem
          data: "AT+CGDCONT?\r\n"

  # 处理收到的短信
  - id: process_sms
    mode: queued
    parameters:
      sender: string
      message: string
      timestamp: string
    then:
      - lambda: |-
          // 更新传感器
          id(sms_sender).publish_state(sender);
          id(sms_content).publish_state(message);
          id(sms_time).publish_state(timestamp);
          id(sms_received_count).publish_state(id(sms_received_count).state + 1);
          
          // 保存最新短信信息
          id(last_sender) = sender;
          id(last_message) = message;
          id(last_timestamp) = timestamp;
          
          ESP_LOGI("sms", "收到短信: 发送者=%s, 内容=%s", sender.c_str(), message.c_str());
      # 发布 MQTT 消息
      - mqtt.publish:
          topic: !lambda 'return "${mqtt_prefix}/${device_name}/sms/received";'
          payload: !lambda |-
            char buf[1024];
            snprintf(buf, sizeof(buf), 
              "{\"sender\":\"%s\",\"message\":\"%s\",\"timestamp\":\"%s\"}",
              id(last_sender).c_str(), 
              id(last_message).c_str(), 
              id(last_timestamp).c_str());
            return std::string(buf);
          retain: false

# 定时器 (用于定时 Ping 保号)
interval:
  - interval: 60s
    then:
      # 定期查询模块状态
      - if:
          condition:
            lambda: 'return id(modem_initialized);'
          then:
            - script.execute: query_status
            
  - interval: 24h
    then:
      # 每24小时 Ping 一次保号
      - if:
          condition:
            switch.is_on: timer_ping_enabled
          then:
            - script.execute: do_ping

# 自定义组件: UART 监听器 (处理 AT 响应和短信通知)
# 注意: 完整的 PDU 解码需要自定义 C++ 代码
external_components:
  - source:
      type: local
      path: components
